```
create user 'cos'@'%' identified by 'cos1234';
GRANT ALL PRIVILEGES ON *.* TO 'cos'@'%';
```
database table 권한 설정 

-------------------------------------------------------
JWT = JSON WEB TOKEN

클라이언트가 서버에 최초 요청시 서버가 세션 ID를 만들어서 Header 에 담아서 보냄

그럼 클라이언트는 쿠키에 세션 ID를 저장하고 다음 요청때 Header 에 세션 ID를 담아서

서버에 요청함, 서버는 그 세션 ID를 목록(세션이라는 저장소)에 있는지 확인하고 DB에 사용자 정보를 응답 받음

세션 ID가 사라지는 3가지 경우

1. 서버가 세션 ID 날리는 경우

2. 사용 브라우저 종료!

3. 특정 시간이 지나면 세션 ID 사라짐

세션의 단점

클라이언트 수가 많읗 때 여러 서버에 로드 밸런싱을 통해 부담을 나눔 => 공통된 세션 저장소를 사용해야 하는데

이때 DB로 그것을 대체할 경우 속도가 매우 느림 (풀스캔) => ( CPU -> RAM (전기적 접근 가능) -> HDD (원판모양으로 풀 스캔) )

so, 전기적 접근이 일어나는 곳에 세션이 저장되어 있어야 I/O 가 일어나지 않고 접근이 빠름 => Redis 라는 서버 사용

------------------------------------------------------------------------

통신 : OSI 7 계층

응용 계층

표현 계층 : 암호화, 압축

세션 계층 : 인증 체크

전송 계층 : TCP/UDP

네트워크 계층 : IP (WAN)

데이터 링크 계층 : IP 안에 몇호 (LAN)

물리 계층 : 광케이블     -> 데이터 전송 ->

TCP (신뢰성 O, 속도 느림) => 웹

UDP (신뢰성 X, 속도 빠름) => 전화, 동영상

------------------------------------------------------------------------------
- CIA
    - C (Confidentiality) -> 기밀성
    - I (Integrity)-> 무결성 (변경)
    - A (Availability) -> 가용성


- RSA
    - 공개키 -> 개인키 (암호화)
    - 개인키 -> 공개키 (전자 서명)


- B 공개키로 문서를 암호화 한 뒤 A의 개인키로 또 암호화

=> A의 공개키로 열리면 인증 o -> B의 개인키로 열어서 문서 확인

-----------------------------------------------------------------

- RFC 문서
    - 벨 연구소에서 쓰던 내부망이랑 다른 대학 간에 연결을 하기위해 점차 http 프로토콜이 생겨남 (RFC 버전이 계속 올라감)

- JWT (RFC 7519) => xxxxx.yyyyy.zzzzz
    - Header => 어떤 알고리즘을 사용해서 서명했는지
    - Payload => 정보
    - Signature => 헤더 + 페이로드 + 개인키 (HMAC SHA256)

HMAC - 시크릿 키를 포함한 암호화 방식

SHA256 - 해쉬

JSON 은 Base64Url 로 암호화

클라이언트 (웹 브라우저)

- 로컬 스토리지에 jwt 값 저장

서버에서는 Base64Url 로 디코딩 한 후,

헤더와 페이로드, 서버가 가지고 있는 Secret key 로 HMAC SHA256 를 이용해서 암호화 한 뒤

시그니처와 비교를 해서 검증(인증)함

------------------------------------------------------------

Authorization : (ID, PW)
=> Basic 방식
=> ID, PW 노출 되면 보안 취약

Authorization : 토큰 <- (ID, PW) - JWT 
=> Bearer 방식
=> 토큰 노출 되어도 서버에서 새로 발급 하면 됨
=> 유효시간 가지고 있음