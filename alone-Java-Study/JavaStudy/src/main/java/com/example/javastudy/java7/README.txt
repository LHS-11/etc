class => 단순한 템플릿
템플릿을 바탕으로 객체(인스턴스) 생성

객체 => 상태(변수) + 행동(메서드)

class 를 만들 때 고려해야 하는 것
1. 상태
2. 생성자
3. 행동
=> 사용자의 입장에서 생각

객체 구성 관계

상속 (IS A 관계)=> 다른 클래스에서 이미 사용 중인 코드를 재사용할 때 유용함
ex) Person (수퍼 클래스) - Student (서브 클래스) => Student IS A Person
서브 클래스가 슈퍼 클래스를 확장하며 서브 클래스는 슈퍼 클래스의 모든 기능을 가지게 됨

기본적으로 클래스가 다른 클래스에서 아무것도 상속 받지 않는다면 Object 클래스(디폴트 값)를 상속받음

하위클래스에서 상위클래스에 있는 메서드를 오버라이딩을 통해 재정의 가능하다.

하위클래스에서 생성자를 생성시 자동으로 상위클래스 생성자 호출

java 에서는 다중 상속이 되지 않음 (C++에선 가능) but 상속 계층은 가능

하위 클래스 변수를 담을 수 있는 상위 클래스 참조 변수를 생성 가능
ex) Pet pet = new Dog(); ( public class Dog extends Pet )

상위 클래스 변수는 하위 클래스 변수를 담을 수 있다.
=> 상위 클래스에서 하위 클래스 변수를 참조 가능


instanceof => 현재 객체가 특정 클래스의 인스턴스인지 알 수 있게 해줌
ex) Animal - Pet - Dog
(하위클래스의 객체) instanceof (상위클래스 or 해당 type) => true -> 현재 객체가 상위 클래스의 인스턴스인지 확인 가능
pet instanceof Animal => true
dog instanceof Pet => true

pet instanceof Dog => false
but
Pet pet=new Dog(); // 만약 pet이 Dog 인스턴스로 생성했다면
pet instanceof Dog => true 가 될 수 있음!!

추상 클래스 => abstract class Animal(){}

추상 메서드는 추상 클래스에서만 생성 가능, 비추상적 메서드는 추상 클래스에서 생성 가능

모든 추상 클래스들은 높은 단계의 알고리즘을 적용하고 자세한 세부정보들은 적용 클래스들에게 맡김

인터페이스와 추상 클래스의 차이 (활용도는 같을 수 있지만 사고 방식 면에서 완전히 다름)
=> 인터페이스의 경우 두 시스템 사이에 소통하길 원할 때(Dummy 알고리즘으로 대체해서 사용하다가 real 알고리즘으로 변경하면 됨 -> 프로젝트는 계속 진행 가능
, 두 클래스 아니면 두 부속이 서로 소통하길 원할 때
=> 추상클래스의 경우 높은 단계의 구조를 제공하고 싶어할 때, 구현의 세세한 부분들을 하위 클래스에 맡기고 싶을 때

다형성 => 같은 것에 여러가지 구현을 부여

인터페이스가 공통 행동을 클래스에게 제공

인터페이스는 외부 인터페이스가 실제로 사용 가능하지 않아도 작업을 계속할 수 있게 해줌 (교체 하면 그만!!) => 통신 계약

인터페이스는 또 다른 인터페이스를 연장 가능

인터페이스 안의 메서드들은 무조건 개방형 (private 사용 X)

자신이 연장하는 인터페이스에 대한 구현이 없는 그저 인터페이스만 구현하는 추상 클래스를 생성 가능
=> 인터페이스에 있는 메서드를 다 구현하고 싶지 않다면 추상 클래스를 통해 implements 해줘야 함

인터페이스 안에서 변수가 아닌 상수를 만들 수 있음, return 값 앞에 default 키워드를 붙이면 구현 가능

추상 클래스와 인터페이스의 차이점

인터페이스는 시행될 수 있는 공통된 행동들을 대표함

인터페이스 종류의 참조 변수는 인터페이스 구현을 가질 수 있음